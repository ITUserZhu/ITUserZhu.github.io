[{"title":"告诫","date":"2016-06-10T14:05:52.000Z","path":"2016/06/10/告诫/","text":"&emsp;&emsp;告诫不等同与劝告，劝告是一种平等的和气的交谈，带有妥协性的语气会使人愉快，而告诫是一种带有时代性、强制性、正确性的命令，可对于一切生命来说，告诫的正确性，是有待发现和探索的。&emsp;&emsp;“告诫”是以自我为中心的雏形，它不理会接受指令者的不满与反抗，以一种欺压似的姿势宣读命令。它带着它那特有的僵化的细胞，试图注入新鲜的血液，以延续这份自以为是的不容欺压的古老的权威。“你不能这样，你不能那样；你只能这样，你只能那样，”这是’告诫’最惯用的语气与态度，语气呆板生硬到让人厌恶， 却还滔滔不绝的展示着它的力量与权威。 &emsp;&emsp;在反抗面前，“告诫”是个加速剂，反抗者讨厌告诫者的理论与言辞，越发激烈的反抗者越要显示自己的正确性。项羽兵败乌江，横遭老者 告诫，在面对老者那于谁看来都无比正确对的理论时，更加加剧了他那反抗的决心。他乃一代英才，乱世枭雄，岂会轻易折腰，更别说在一个老者面前弃甲曳兵而走了，无论后人怎样的扼腕叹息，谁能想到还有这样一种告诫的成分加速的项羽的死亡。就像李清照所说的，“生当为人杰，死亦为鬼雄”我想，那时的他，大抵也抱了这种思想。而再往前追溯，鸿门宴中，若不是项庄的一再告诫，又怎会招来项羽的置之不理，有人要说，告诫他是好的呀，但你是否想过，他那样一个位居高位的人，有什么理由会倒在比他低一等的人手中，那种长久的滋生的地位心理，是决不允许自己向他低头的，或许有一刻他也觉得他错了，但面对步步紧逼的权威告诫，这位铁血汉子，又怎会自愿像提偶一样任人操控呢。 &emsp;&emsp;人活当下，并不自在，总有许多告诫缠绕着你，像寄生藤缠绕着树一样，你越挣脱，越难过，“告诫”是个假意的救世者，它以它特有的理论去指导人们，以此来满足它那虚伪的骄傲的权威。强烈的压迫感和实践论使人无法排解，所以，便有了，要么沉默的接受，要么响亮的爆发。当我们处于孩童时期，我们尚未形成自己的思想时，我们不得不依附这些权威来获得生存，这时的权威就像母亲的乳汁，喝下去，你才能具备力量。随着年龄的加大，你经历的多了，心智逐渐健全，你便立刻反击这模式化板块化的告诫，这时的告诫不再是你生活的必需品，而成为你拓展道路的绊脚石了，你必须踢开它。然而此时的告诫也是不会甘心失去多年的领导地位，于是，一个叛逆的名号便恶狠狠的安插在你的头上了，这种结合着时代的抨击，看似无比正确令人同情的爱，不过是夹杂了控制者的统治欲，只是起了一个好听的名字，以此来安稳自己那心不平理不直的言论罢了。 &emsp;&emsp;“告诫”固然有它存在的不合理性，但它也是不可消亡的一部分，压迫和反抗是对立的，压迫一旦不存在，反抗自然而然的就会消亡，历史是这样，自然是这样，人世也是这样。我们大喊讨厌告诫，有时却不得不听从它的安排，告诫在一定的条件下，是有它自身所存在的意义的，告诫或好或歹，都是通过被告诫者的实践和认知来表现的，我们不能完全的否认告诫，但这不意味着我们会屈从于告诫，看告诫，读告诫，都是不能用单一的角度去审视的。 &emsp;&emsp;铺好的路不美，嚼过的饭不香，只有睁开自己的眼睛，去领略，去体会，去感悟。你才能知道这世界，别有洞天。 原文地址"},{"title":"Gulp工具使用","date":"2016-06-08T08:22:28.000Z","path":"2016/06/08/Gulp使用/","text":"npm -Node的包管理工具 node package manager npm官网 淘宝镜像 cnpm 安装 node 下载node的安装包，直接安装 验证是否安装成功 1 使用win + r键，打开运行窗口 2 输入cmd，敲回车，进入到命令行工具 3 输入node -v，检测node是否安装成功 4 输入npm -v，检测 npm 使用淘宝镜像12npm config set registry https://registry.npm.taobao.org --globalnpm config set disturl https://npm.taobao.org/dist --global 使用npm 初始化npm配置文件：npm init 会生成一个名为：package.json 的文件 使用npm下载包 命令：npm install [名称] --save 参数--save 会修改 package.json，添加”dependencies”依赖项 注意：会在当前目录中添加一个名为node_modules的文件夹 文件夹中存放了，所有下载的包文件 下载指定版本号的包：npm install [包名称]@版本号 --save package.json 作用：npm可以根据该文件，配合npm install --production命令，下载配置中的依赖项 优势：不用每次都拷贝依赖项，只需要使用package.json即可 移除包 命令：npm remove [名称] --save 作用：删除包文件，并修改package.json Gulp 前端自动化构建工具 官网 中文网 在线压缩 概述 Gulp：用自动化构建工具增强你的工作流程！ 1 易于使用 2 高效，利用node.js强大的流（文件流），快速完成构建 3 构建工作就像一系列 流管道（水流经过管道） 应用场景 项目发布上线之前对项目进行构建 自动完成一系列重复的操作 12js、css、html文件的压缩、混淆、合并、监视文件变化、同步刷新浏览器 等等Less ==&gt; CSS 或者 Sass ==&gt; CSS 安装Gulp命令行 1 全局安装 gulp npm install --global gulp 2 作为项目的开发依赖（devDependencies）安装： npm install --save-dev gulp 其他构建工具 Grunt 、webpack 核心方法 task() ：gulp中是以任务为单位来实现功能 src() ：传入路径参数，获取到要处理的指定文件 dest() ：指定处理后的文件输出路径 watch()：监视文件的变化，做出相应的处理 写任务的步骤 注意：任务写在 gulpfile.js 文件中，这个文件需要我们自己创建 123456789101112// 1 得到 gulp 模块var gulp = require(\"gulp\");// 2 新建任务gulp.task(\"js\", function() &#123; // 使用 src 方法，根据路径 \"./app.js\" 找到app.js文件 gulp.src(\"./app.js\") // 使用 dest 方法，执行输出路径 .pipe(gulp.dest(\"./dist\"));&#125;);// 3 执行： `gulp js` 命令 使用gulp的插件 gulp-less：将less转化为css gulp-uglify：压缩和混淆js代码 gulp-concat：合并js/css文件 gulp-cssnano：压缩css代码 gulp-htmlmin：压缩html代码 htmlmin文档 browser-sync：同步刷新浏览器 以上插件都使用：npm install gulp-[名称] --save-dev 安装 12npm install --save-dev gulp gulp-uglify gulp-concat gulp-cssnano gulp-htmlmin gulp-lessnpm install --save-dev browser-sync 参考文章 Gulp中文网 -文档 Gulp 入门 Gulp+BrowserSync 单独使用 browser-sync 作用：更改代码之后自动刷新浏览器 安装 命令：npm install browser-sync -g 全局安装 监视 命令：browser-sync start --server --files &quot;index.html&quot; 监视单个文件：-- files &quot;index.html&quot; 监视多个文件：-- files &quot;index.html, test.css&quot; 监视目录文件：-- files &quot;./css/*.css&quot; 监视所有文件：-- files &quot;*.*&quot; 优势 动态重新加载样式文件，而不是刷新页面，避免繁琐的操作 前提：样式放到一个单独的css文件中 其他应用 管理地址：UI: http://localhost:3001 多浏览器同步测试 1231 同步事件触发2 同步浏览器滚动3 同步文本框内容"},{"title":"node整理","date":"2016-05-10T09:12:26.000Z","path":"2016/05/10/Node/","text":"Node 是一个可以解析和执行js的一个运行时(运行环境)Node 不同于浏览器,不再关心GUI图形界面,专注于数据处理 文件中的数据 网络中的数据 数据库中的数据 网络服务 Node 特点: Event drivern 事件驱动 非阻塞IO模型(异步编程模型) 单线程 跨平台 轻量高效 path 环境变量 将可执行文件所属绝对路径以’英文分号’作为分隔符添加到path环境变量中 在环境变量中田间一个变量名(大写程序名_HOME),变量值为可执行文件所属绝对路径 然后在Path环境中以英文分号作为分割使用 %变量名% 来对你的变量进行引用 这种方式好处就是方便维护 Node 中的JavaScript 123456Ecmascript if /else / var / function... Date / Math ...ConsolesetTimeout clearTimeoutsetInterval claerInterval Node内置核心模块 作用: 每一个核心模块都专注于处理某个功能.如fs模块专注于文件操作 使用方式: 所有的核心模块都提供了一系列的API共你调用.第一步必须先调用 require 例如 var fs = require(fs) 文件操作 读取文件 readFile 写入文件 writeFile 监视文件 watchFile 读取目录 readdir 读取的是文件名和目录名称 http 搭建一个能响应 hello world 的服务 搭建一个根据不同URL响应不同的内容(写死的字符串) 搭建一个能根据不同URL响应不同文件 在Node 中使用模版引擎 模版引擎与DOM对象没有关系 http-server它是基于Node 开发的一个全局命令行工具,可以快速托管你的静态资源 第一步: 安装 12npm i -g http-servernpm install --global http-server 卸载 http-server1npm unistall --global http-server 模块化 在Node 中,为每一个文件都提供了一个require 函数 没一个文件模块都是一个单独的私有作用域 如果想要在一个模块中向外导出一些被别人访问的成员: 通过:module.exports向外导出,没一个模块都有一个对象: module.exports,默认是一个空对象 require 函数的作用:用来加载文件模块 内置模块: 例如 fs / http 第三方: art-template / marked... require 函数的第一个作用 执行被加载模块中的代码 得到被加载模块中导出的接口对象 异步编程思维 清楚理解异步代码的执行过程 能做到封装一个函数（内部由异步操作产生该函数的结果） 所有的异步操作都在普通操作完成之后才会执行 所有函数中通过异步操作得到的结果一定是通过callback回调函数来获取 上层定义 下层调用 模块天生就是一个私有作用域,外部拿不到对于同一个模块,被多次加载,会被缓存起来,以后再加载就直接读取缓存结果 加载过的模块的导出接口会被放到缓存中 模块的加载执行顺序,取决于require函数出现的位置 npm常用命令 npm--help 查看 npm 工具使用帮助 npm--version 查看版本 npm --global npm 升级版本 npm -h需要查看的工具 查看工具的使用帮助 npm uninstall [--save] 卸载当前项目中某个包 安装全局命令行工具 在node 中,还有一种包比较特殊,这种包被称为全局命令行工具,这种不是用在项目中辅助调用的,而是提供一个工具供你在终端使用 npm install --global http-server nrm 多镜像缘切换 安装 npm install --global nrm 自动同步修改代码重启服务器 nodemon第一:安装npm i -g nodemon第二: 使用node app.js 通过 nodemon app.js 设置响应头部123res.writeHead(200,&#123; 'Content-Type': 'text/html; charset=utf-8'&#125;) 文件操作路径 在文件操作中,绝对路径无非就是两种形式: c:/a/b/a.txt 绝对路径 a/b/a.txt 相对路径 相对路径 ./data/a.txt 这里的相对路径表示在哪里执行Node命令,相对路径就相对于谁 __filenmae 和 __dirname + __filenmae永远获取到的都是当前文件的绝对路径 + __dirname永远获取到的都是当前文件所属目录的绝对路径 __dirname + &#39;\\\\data.txt&#39; 在windows上 ,路径分隔是反斜杠: \\ 可以利用path.sep属性获取当前操作系统的路径分隔符 path.join(__dirname,&#39;../a.txt&#39;) 将多个字符串拼接完整的路径 ‘../‘代表进入上一级 path.basename 获取有后缀名的文件 path.dirname 获取第一个路径的目录部分 path.normalize(path) 将一个非标准路径转换成标准路径 path.resolve([...path]) 将一个路径转为动态的绝对路径,但是转出来的绝对路径还是相对于Node执行命令的终端位置 path.parse(&#39;c:\\\\paht\\\\file.txt&#39;) 路径转为对象 对应path.format({}) 在node操作路径的时候,可以使用正斜杠作为路径操作符,因为Node在真正处理文件资源的时候,会自动转换 web路径永远相对于当前页面的url路径 , url只是个标识, 关键在于html页面中的资源引用路径到底相对于什么在 web 中,一切页面中的资源请求路径都相对于当前使用这个页面的 link href img src script src iframe href a href post 请求 node中获取数据 querystring.parse(data) 把查询字符串转换成对象 参数传入: data = ‘name=aa&amp;age=18’ 将表单的enctype 设置为multipart/form-data awesome-名字 git搜索常用的插件"},{"title":"酱油诗","date":"2015-08-16T14:23:12.000Z","path":"2015/08/16/愁诗/","text":"秋风易冷花自堕,孤情独坐楼中默.千万愁思理断肠,独种心中泪满裳.伤的遍体何所为?因你喜新厌旧配!物是人非事事逝,人否物是一一忆.未懂吾心伤几何?怎爱他人共一生! &emsp;&emsp;每行第二个的,算是一首藏头诗吧!"},{"title":"每个人都是一场梦","date":"2015-07-28T09:06:12.000Z","path":"2015/07/28/都是一场梦/","text":"&emsp;&emsp;冷冷的晚风，抚摸着你的脸庞或臂膀，凄清的月光，亲吻你的额头或耳畔，星星眨着眼，用它微弱而坚定的光芒，告诉你，此时的深夜，你在想的，一定是你爱的人。&emsp;&emsp;时光的羽翼已渐渐被叫做岁月的剪刀，削剪了太多太多，而思念的大潮，却永远在涌动，无法覆灭，上帝给了我们渴盼，也给了我们失望，上帝，给了我们夜晚，也给了我们思念。 &emsp;&emsp;你爱的人一定是你心疼的人，而你心疼的人，一定会是你在深夜，还能清晰想清楚她的面旁的人，即使曾经的海誓与山盟，已然云散烟消，可曾经的期盼，却只增不减，在各自疲于奔命的旅途，都忘了太多，丢了太多，因为我们都知道，现在能拥有的都是我们无法舍弃的，偶尔的夜晚，想找个人聊聊天，偶尔的深夜，想拨通一个电话号码，或亲人，或朋友，或伴侣。 &emsp;&emsp;不是所有能到埃菲尔的希望都能成真，不是所有能在富士山下许愿的情侣都会厮守，不是所有能在泰晤士河沐浴的教徒都能圆满，但，所有能在深夜想起的人，都将会是一辈子放不下的依赖。将是深爱的一人。 &emsp;&emsp;夜，为什么可怕，因为你没有依靠，所以觉得可怕，孤孤单单的深夜，模糊的不能再模糊的视线，都让你无所适从，无助，担心，焦虑，全在这一霎那，涌现，可你是否知道，此时的深夜，也有人再想你或许是行走匆匆的过客，或许相熟很久的朋友，可能这就是，明月装饰了你的窗子，而你装饰了别人的梦吧，是啊，我们每个人都可能成为，别人深夜所想起的人，每个人都是别人的一个梦，每个人都是一首诗。"},{"title":"Express的使用","date":"2015-07-22T07:08:32.000Z","path":"2015/07/22/Express/","text":"基础+中间件 数据库 使用node操作数据 Express 一个基于Nodejs快速web开发框架 做网站后台 中间件 express 核心就是面向中间件编程 app.use(function(req,res){//handle})中间件: 任意请求都会进来,不关心请求路径和请求方法 app.use(route,function(req,res){//handle})中间件:只有该请求路径开头的才会进来执行+app.get(‘请求路径’,function(req,res){})只有以get请求 第一个参数:请求路径+app.post(‘请求路径’,function(req,res){})只有以post请求 第一个参数:请求路径 对于同一次请求,流通多个中间件都是同一个req,res对象 12345678app.use(function(req,res,next)&#123; console.log(11) next()&#125;)//调用next()才会执行下一个被匹配的中间件app.use(function(req,res) &#123; console.log(222)&#125;) API1.express express() 得到一个实例app express.static() 方便地托管静态文件唯一中间件 express.Router() 可使用 express.Router 类创建模块化、可挂载的路由句柄 2.Application 12app.get() app.post() 设置路由 通过 app 调用对应的 get 或 post 方法 根据不同的请求方法 + 请求路径，转发到具体的处理函数 这里的路由中的第一个参数需要传入一个字符换：请求路径（pathname，不包含查询字符串） 请求处理函数需要接收两个参数：req 和 res req：请求对象 可以通过请求对象获取一些客户端的请求数据，例如请求 URL、请求方法、请求查询字符串 等数据 req 也是在原来的基础之上，扩展添加了一些有用的方法或属性 例如：req.query res：响应对象 可以给客户端发送响应数据 Express 在基于原来的 res 基础之又提供了一些快捷便利的方法 例如：res.redirect() app.listen() 监听 端口,启动服务器 12345678app.use(function (req, res) &#123; // handle &#125;)//中间件：任何请求都会进来，不关心请求路径和请求方法app.use(&apos;请求路径&apos;, function (req, res) &#123; // handle &#125;) //中间件：只有该请求路径开头的才会进来执行app.get(&apos;请求路径&apos;, function (req, res) &#123; // handle &#125;) //只有以 get 请求 第一个参数：请求路径的时候才会进来app.post(&apos;请求路径&apos;, function (req, res) &#123; // handle &#125;)//只有以 post 请求 第一个参数：请求路径的时候才会进来 3.Request req.url 获取请求路径 req.method 获取请求方法 req.headers 获取请求头 req.hostname 获取请求主机名 req.ip 获取Ip req.query 获取请求字符串 req.body 获取主体 req.params req.cookie req.path req.baseUrl req.originalUrl MongoDB64 位版本启动 MongoDB 数据服务： 12mongod --dbpath=C:\\data\\dbmongod --dbpath C:\\data\\db 32 位版本使用下面的命令启动数据服务： 1mongod --dbpath 数据存储路径 --journal --storageEngine=mmapv1 提示：如果不加 --dbpath, mongod 会自动使用 执行命令所属磁盘根目录/data/db 目录作为自己的数据存储路径，所以，如果当前磁盘已经有了 磁盘根路径\\data\\db 目录了，可以省略 --dbpath。 执行完上面的命令并成功开启 MongoDB 数据服务实例之后，就把该控制台最小化到一边就可以了，千万不要关闭，否则关闭终端就是关闭数据库了，如果对数据库的操作结束，可以打开该控制台通过 Ctrl + C 关闭或者直接关闭终端。 基本操作命令 show dbs 查看当前服务实例上所有的数据库 use 数据库名称 这个命令表示切换到指定的数据库 如果没有，也不会创建 如果已经有了，则表示切换到这个数据库对该数据库进行操作 连接到数据库之后，默认有一个变量叫做：db，终端默认把 db 赋值给了 test db 查看当前所处的数据库 db.集合名称.insert(数据文档) show collections 查看当前数据库中所有的集合 db.集合名称.find() 查询指定集合中所有的数据 可以通过 db.集合名称.find().pretty() 美化输出格式 默认是查询所有，可以通过：db.集合名称.find({查询条件}) 按条件查询集合中的数据 db.集合名称.update({更新条件}, {要更新的字段}) 更新指定集合数据 db.集合名称.remove({删除条件}) 删除指定集合中的数据"}]